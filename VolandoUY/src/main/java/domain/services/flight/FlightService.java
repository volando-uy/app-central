package domain.services.flight;

import domain.dtos.flight.BaseFlightDTO;
import domain.dtos.flight.FlightDTO;
import domain.dtos.flightRoute.FlightRouteDTO;
import domain.dtos.seat.BaseSeatDTO;
import domain.models.enums.EnumTipoAsiento;
import domain.models.flight.Flight;
import domain.models.flightRoute.FlightRoute;
import domain.models.seat.Seat;
import domain.models.user.Airline;
import domain.services.flightRoute.IFlightRouteService;
import domain.services.seat.ISeatService;
import domain.services.user.IUserService;
import factory.ControllerFactory;
import factory.RepositoryFactory;
import factory.ServiceFactory;
import infra.repository.flight.FlightRepository;
import infra.repository.flight.IFlightRepository;
import lombok.AllArgsConstructor;
import lombok.Setter;
import shared.constants.ErrorMessages;
import shared.utils.CustomModelMapper;
import shared.utils.ValidatorUtil;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class FlightService implements IFlightService {

    private final CustomModelMapper customModelMapper = ControllerFactory.getCustomModelMapper();

    @Setter
    private IUserService userService;

    @Setter
    private IFlightRouteService flightRouteService;

    @Setter
    private ISeatService seatService;

    // Al sacar esto para el repo, hay que agregar
    // el @AllArgsConstructor y eliminar el constructor
    private final IFlightRepository flightRepository;

    // Constructor
    public FlightService() {
        this.flightRepository = RepositoryFactory.getFlightRepository();
    }

    @Override
    public BaseFlightDTO createFlight(BaseFlightDTO baseFlightDTO, String airlineNickname, String flightRouteName) {

        // Verificar si el vuelo ya existe
        Flight flight = customModelMapper.map(baseFlightDTO, Flight.class);
        if (_flightExists(flight)) {
            throw new UnsupportedOperationException(String.format(ErrorMessages.ERR_FLIGHT_ALREADY_EXISTS, flight.getName()));
        }

        // Validar el vuelo
        ValidatorUtil.validate(flight);

        // Obtener la aerolínea por su nickname
        // Tira throw si no existe.
        Airline airline = userService.getAirlineByNickname(airlineNickname, true);

        // Obtener la ruta de vuelo por su nombre
        // Tira throw si no existe.
        FlightRoute flightRoute = flightRouteService.getFlightRouteByName(flightRouteName, true);
        if (!flightRoute.getAirline().getNickname().equals(airline.getNickname())) {
            throw new IllegalArgumentException(String.format(ErrorMessages.ERR_FLIGHT_ROUTE_NOT_BELONGS_TO_AIRLINE, flightRouteName, airlineNickname));
        }

        // Crear los asientos de turista del vuelo
        List<Seat> seats = new ArrayList<>();
        for (int i = 1; i <= flight.getMaxEconomySeats(); i++) {
            BaseSeatDTO baseSeatDTO = new BaseSeatDTO(
                    null, // ID is generated by the database
                    String.format("T-%d", i),
                    true,
                    flightRoute.getPriceTouristClass(),
                    EnumTipoAsiento.TURISTA
            );
            seats.add(seatService.createSeatWithoutPersistance(baseSeatDTO));
        }
        for (int i = 1; i <= flight.getMaxBusinessSeats(); i++) {
            BaseSeatDTO baseSeatDTO = new BaseSeatDTO(
                    null, // ID is generated by the database
                    String.format("B-%d", i),
                    true,
                    flightRoute.getPriceBusinessClass(),
                    EnumTipoAsiento.EJECUTIVO
            );
            seats.add(seatService.createSeatWithoutPersistance(baseSeatDTO));
        }

        // Guardamos el vuelo y actualizamos la aerolínea y la ruta de vuelo
        flightRepository.saveFlightWithSeatsAndAddToAirlineAndAddToFlightRoute(flight, airline, flightRoute, seats);

        return customModelMapper.map(flight, BaseFlightDTO.class);
    }


    @Override
    public List<FlightDTO> getAllFlights(boolean full) {
        return flightRepository.findAll().stream()
                .map(fl -> full ? customModelMapper.mapFullFlight(fl) : customModelMapper.map(fl, FlightDTO.class))
                .toList();
    }

    @Override
    public FlightDTO getFlightDetailsByName(String name, boolean full) {
        // Comprobamos que el vuelo existe
        // Tira throw si no existe
        Flight flight = this.getFlightByName(name, full);

        return full ? customModelMapper.mapFullFlight(flight) : customModelMapper.map(flight, FlightDTO.class);
    }

    @Override
    public Flight getFlightByName(String flightName, boolean full) {
        // Comprobamos que el vuelo existe
        Flight flight = full ? flightRepository.getFullFlightByName(flightName) : flightRepository.getFlightByName(flightName);
        if (flight == null) {
            throw new IllegalArgumentException(String.format(ErrorMessages.ERR_FLIGHT_NOT_FOUND, flightName));
        }
        return flight;
    }

    @Override
    public List<FlightDTO> getAllFlightsByRouteName(String flightRouteName, boolean full) {
        return flightRepository.getFlightsByRouteName(flightRouteName).stream()
                .map(fl -> full ? customModelMapper.mapFullFlight(fl) : customModelMapper.map(fl, FlightDTO.class))
                .toList();
    }

    @Override
    public List<FlightDTO> getAllFlightsByAirlineNickname(String airlineNickname, boolean full) {
        // Comrpobamos que la aerolínea existe
        // Tira throw si no existe
        userService.getAirlineByNickname(airlineNickname, false);

        // Retornamos el DTO de todos los vuelos de la aerolinea
        return flightRepository.getAllByAirlineNickname(airlineNickname).stream()
                .map(fl -> full ? customModelMapper.mapFullFlight(fl) : customModelMapper.map(fl, FlightDTO.class))
                .toList();
    }

    private boolean _flightExists(Flight flight) {
        return flightRepository.existsByName(flight.getName());
    }
    
}
